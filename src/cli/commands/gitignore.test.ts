import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import { fileExists, readFileContent, writeFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";
import { gitignoreCommand } from "./gitignore.js";

vi.mock("../../utils/file.js");
vi.mock("../../utils/logger.js");

describe("gitignoreCommand", () => {
  const mockGitignorePath = "/workspace/.gitignore";

  beforeEach(() => {
    vi.spyOn(process, "cwd").mockReturnValue("/workspace");

    vi.mocked(logger.info).mockImplementation(() => {});
    vi.mocked(logger.success).mockImplementation(() => {});

    vi.mocked(fileExists).mockResolvedValue(false);
    vi.mocked(readFileContent).mockResolvedValue("");
    vi.mocked(writeFileContent).mockResolvedValue(undefined);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe("when .gitignore does not exist", () => {
    it("should create a new .gitignore with all AI tool rules", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).not.toHaveBeenCalled();
      expect(writeFileContent).toHaveBeenCalledWith(
        mockGitignorePath,
        expect.stringContaining("# Generated by Rulesync"),
      );
      expect(logger.success).toHaveBeenCalledWith("Updated .gitignore with rulesync entries:");
    });

    it("should include all expected AI tool patterns", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/.clinerules/workflows/");
      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.opencode/agent/");
      expect(content).toContain("**/.gemini/memories/");
      expect(content).toContain("**/.roo/rules/");
      expect(content).toContain("**/.kilocode/skills/");
      expect(content).toContain("**/.kilocode/rules/");
      expect(content).toContain("**/.kilocode/workflows/");
      expect(content).toContain("**/.roo/skills/");
      expect(content).toContain("**/.aiignore");
      expect(content).toContain("**/.mcp.json");
      expect(content).toContain("**/.github/agents/");
      expect(content).toContain("**/.github/hooks/");
      expect(content).toContain("**/.github/prompts/");
      expect(content).toContain("**/.warp/");
      expect(content).toContain("**/.codex/memories/");
      expect(content).toContain("**/.codex/skills/");
      expect(content).not.toContain("**/.agent/rules/");
      expect(content).not.toContain("**/.agent/workflows/");
      expect(content).not.toContain("**/.agent/skills/");
    });

    it("should format content properly with newline at end", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\n$/);
      expect(content).toContain("# Generated by Rulesync");
    });
  });

  describe("when .gitignore exists but is empty", () => {
    it("should add all rules to empty .gitignore", async () => {
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue("");

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).toHaveBeenCalledWith(
        mockGitignorePath,
        expect.stringContaining("# Generated by Rulesync"),
      );
      expect(logger.success).toHaveBeenCalledWith("Updated .gitignore with rulesync entries:");
    });
  });

  describe("when .gitignore exists with existing content", () => {
    it("should append rulesync block to existing content", async () => {
      const existingContent = "node_modules/\n*.log\n";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain(existingContent.trim());
      expect(content).toContain("# Generated by Rulesync");
      expect(content).toMatch(/\*\.log\n\n# Generated by Rulesync/);
    });

    it("should preserve existing content with proper spacing", async () => {
      const existingContent = "node_modules/\n*.log";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\*\.log\n\n# Generated by Rulesync/);
    });
  });

  describe("when rulesync entries already exist scattered in the file", () => {
    it("should remove scattered entries and consolidate at the end", async () => {
      const existingContent = `node_modules/
*.log
**/.cursor/
dist/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("node_modules/");
      expect(content).toContain("*.log");
      expect(content).toContain("dist/");

      const cursorMatches = content.match(/\*\*\/\.cursor\//g);
      expect(cursorMatches).toHaveLength(1);

      const rulesyncIndex = content.indexOf("# Generated by Rulesync");
      const cursorIndex = content.indexOf("**/.cursor/");
      expect(cursorIndex).toBeGreaterThan(rulesyncIndex);
    });

    it("should remove legacy header and entries", async () => {
      const existingContent = `node_modules/
# Generated by rulesync - AI tool configuration files
**/.cursor/

dist/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).not.toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toContain("# Generated by Rulesync");
      expect(content).toContain("node_modules/");
      expect(content).toContain("dist/");
    });
  });

  describe("when .gitignore is already up to date", () => {
    it("should report that .gitignore is already up to date", async () => {
      const rulesyncBlock = `# Generated by Rulesync
.rulesync/skills/.curated/
**/AGENTS.md
**/.agents/
**/.augmentignore
**/.augment/rules/
**/.augment-guidelines
**/CLAUDE.md
**/CLAUDE.local.md
**/.claude/CLAUDE.md
**/.claude/CLAUDE.local.md
**/.claude/memories/
**/.claude/rules/
**/.claude/commands/
**/.claude/agents/
**/.claude/skills/
**/.claude/settings.local.json
**/.mcp.json
**/.clinerules/
**/.clinerules/workflows/
**/.clineignore
**/.cline/mcp.json
**/.codexignore
**/.codex/memories/
**/.codex/skills/
**/.codex/agents/
**/.codex/config.toml
**/.cursor/
**/.cursorignore
**/.factory/rules/
**/.factory/commands/
**/.factory/droids/
**/.factory/skills/
**/.factory/mcp.json
**/.factory/settings.json
**/GEMINI.md
**/.gemini/memories/
**/.gemini/commands/
**/.gemini/subagents/
**/.gemini/skills/
**/.geminiignore
**/.goosehints
**/.goose/
**/.gooseignore
**/.github/copilot-instructions.md
**/.github/instructions/
**/.github/prompts/
**/.github/agents/
**/.github/skills/
**/.github/hooks/
**/.vscode/mcp.json
**/.junie/guidelines.md
**/.junie/mcp.json
**/.kilocode/rules/
**/.kilocode/skills/
**/.kilocode/workflows/
**/.kilocode/mcp.json
**/.kilocodeignore
**/.kiro/steering/
**/.kiro/prompts/
**/.kiro/skills/
**/.kiro/agents/
**/.kiro/settings/mcp.json
**/.aiignore
**/.opencode/memories/
**/.opencode/command/
**/.opencode/agent/
**/.opencode/skill/
**/.opencode/plugins/
**/QWEN.md
**/.qwen/memories/
**/replit.md
**/.roo/rules/
**/.roo/skills/
**/.rooignore
**/.roo/mcp.json
**/.roo/subagents/
**/.warp/
**/WARP.md
.rulesync/rules/*.local.md
rulesync.local.jsonc
!.rulesync/.aiignore
`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(rulesyncBlock);
      vi.mocked(writeFileContent).mockClear();
      vi.mocked(logger.success).mockClear();
      vi.mocked(logger.info).mockClear();

      await gitignoreCommand();

      expect(logger.success).toHaveBeenCalledWith(".gitignore is already up to date");
      expect(writeFileContent).not.toHaveBeenCalled();
    });
  });

  describe("logging behavior", () => {
    it("should log each added rule", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(logger.success).toHaveBeenCalledWith("Updated .gitignore with rulesync entries:");

      expect(logger.info).toHaveBeenCalledWith("  **/.cursor/");
      expect(logger.info).toHaveBeenCalledWith("  **/.kilocode/rules/");
      expect(logger.info).toHaveBeenCalledWith("  **/.opencode/agent/");
      expect(logger.info).toHaveBeenCalledWith("  **/CLAUDE.md");
    });

    it("should log Antigravity workaround info after update", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(logger.info).toHaveBeenCalledWith(expect.stringContaining("Google Antigravity"));
      expect(logger.info).toHaveBeenCalledWith(
        "   You can add the following to .git/info/exclude instead:",
      );
      expect(logger.info).toHaveBeenCalledWith("   **/.agent/rules/");
      expect(logger.info).toHaveBeenCalledWith("   **/.agent/workflows/");
      expect(logger.info).toHaveBeenCalledWith("   **/.agent/skills/");
      expect(logger.info).toHaveBeenCalledWith(
        "   For more details: https://github.com/dyoshikawa/rulesync/issues/981",
      );
    });

    it("should not log Antigravity workaround info when already up to date", async () => {
      const rulesyncBlock = `# Generated by Rulesync
.rulesync/skills/.curated/
**/AGENTS.md
**/.agents/
**/.augmentignore
**/.augment/rules/
**/.augment-guidelines
**/CLAUDE.md
**/CLAUDE.local.md
**/.claude/CLAUDE.md
**/.claude/CLAUDE.local.md
**/.claude/memories/
**/.claude/rules/
**/.claude/commands/
**/.claude/agents/
**/.claude/skills/
**/.claude/settings.local.json
**/.mcp.json
**/.clinerules/
**/.clinerules/workflows/
**/.clineignore
**/.cline/mcp.json
**/.codexignore
**/.codex/memories/
**/.codex/skills/
**/.codex/agents/
**/.codex/config.toml
**/.cursor/
**/.cursorignore
**/.factory/rules/
**/.factory/commands/
**/.factory/droids/
**/.factory/skills/
**/.factory/mcp.json
**/.factory/settings.json
**/GEMINI.md
**/.gemini/memories/
**/.gemini/commands/
**/.gemini/subagents/
**/.gemini/skills/
**/.geminiignore
**/.goosehints
**/.goose/
**/.gooseignore
**/.github/copilot-instructions.md
**/.github/instructions/
**/.github/prompts/
**/.github/agents/
**/.github/skills/
**/.github/hooks/
**/.vscode/mcp.json
**/.junie/guidelines.md
**/.junie/mcp.json
**/.kilocode/rules/
**/.kilocode/skills/
**/.kilocode/workflows/
**/.kilocode/mcp.json
**/.kilocodeignore
**/.kiro/steering/
**/.kiro/prompts/
**/.kiro/skills/
**/.kiro/agents/
**/.kiro/settings/mcp.json
**/.aiignore
**/.opencode/memories/
**/.opencode/command/
**/.opencode/agent/
**/.opencode/skill/
**/.opencode/plugins/
**/QWEN.md
**/.qwen/memories/
**/replit.md
**/.roo/rules/
**/.roo/skills/
**/.rooignore
**/.roo/mcp.json
**/.roo/subagents/
**/.warp/
**/WARP.md
.rulesync/rules/*.local.md
rulesync.local.jsonc
!.rulesync/.aiignore
`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(rulesyncBlock);
      vi.mocked(logger.info).mockClear();

      await gitignoreCommand();

      const allInfoCalls = vi.mocked(logger.info).mock.calls.map((call) => call[0]);
      const antigravityMessages = allInfoCalls.filter(
        (msg) => typeof msg === "string" && msg.includes("Antigravity"),
      );
      expect(antigravityMessages).toHaveLength(0);
    });
  });

  describe("error handling", () => {
    it("should handle file existence check errors", async () => {
      vi.mocked(fileExists).mockRejectedValue(new Error("Permission denied"));

      await expect(gitignoreCommand()).rejects.toThrow("Permission denied");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).not.toHaveBeenCalled();
      expect(writeFileContent).not.toHaveBeenCalled();
    });

    it("should handle file read errors", async () => {
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockRejectedValue(new Error("Read error"));

      await expect(gitignoreCommand()).rejects.toThrow("Read error");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).not.toHaveBeenCalled();
    });

    it("should handle file write errors", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);
      vi.mocked(writeFileContent).mockRejectedValue(new Error("Write error"));

      await expect(gitignoreCommand()).rejects.toThrow("Write error");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).toHaveBeenCalled();
      expect(logger.success).not.toHaveBeenCalled();
    });
  });

  describe("path handling", () => {
    it("should use correct .gitignore path based on current working directory", async () => {
      const testCwd = "/different/path";
      vi.spyOn(process, "cwd").mockReturnValue(testCwd);
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(`${testCwd}/.gitignore`);
      expect(writeFileContent).toHaveBeenCalledWith(`${testCwd}/.gitignore`, expect.any(String));
    });
  });

  describe("content formatting", () => {
    it("should handle existing content with trailing whitespace", async () => {
      const existingContent = "node_modules/\n*.log   \n   ";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\*\.log\n\n# Generated by Rulesync/);
    });

    it("should ensure proper line separation between existing and new content", async () => {
      const existingContent = "node_modules/";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/node_modules\/\n\n# Generated by Rulesync/);
    });

    it("should handle rulesync block in the middle of file", async () => {
      const existingContent = `node_modules/
# Generated by Rulesync
**/.cursor/

other-stuff/
dist/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("node_modules/");
      expect(content).toContain("other-stuff/");
      expect(content).toContain("dist/");

      const rulesyncIndex = content.indexOf("# Generated by Rulesync");
      const otherStuffIndex = content.indexOf("other-stuff/");
      expect(rulesyncIndex).toBeGreaterThan(otherStuffIndex);
    });
  });
});
