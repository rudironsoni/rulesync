import { join } from "node:path";

import { fileExists, readFileContent, writeFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";

const RULESYNC_HEADER = "# Generated by Rulesync";
const LEGACY_RULESYNC_HEADER = "# Generated by rulesync - AI tool configuration files";

const RULESYNC_IGNORE_ENTRIES = [
  // Rulesync curated (fetched) skills
  ".rulesync/skills/.curated/",
  // AGENTS.md
  "**/AGENTS.md",
  "**/.agents/",
  // Augment
  "**/.augmentignore",
  "**/.augment/rules/",
  "**/.augment-guidelines",
  // Claude Code
  "**/CLAUDE.md",
  "**/CLAUDE.local.md",
  "**/.claude/CLAUDE.md",
  "**/.claude/CLAUDE.local.md",
  "**/.claude/memories/",
  "**/.claude/rules/",
  "**/.claude/commands/",
  "**/.claude/agents/",
  "**/.claude/skills/",
  "**/.claude/settings.local.json",
  "**/.mcp.json",
  // Cline
  "**/.clinerules/",
  "**/.clinerules/workflows/",
  "**/.clineignore",
  "**/.cline/mcp.json",
  // Codex
  "**/.codexignore",
  "**/.codex/memories/",
  "**/.codex/skills/",
  "**/.codex/agents/",
  "**/.codex/config.toml",
  // Cursor
  "**/.cursor/",
  "**/.cursorignore",
  // Factory Droid
  "**/.factory/rules/",
  "**/.factory/commands/",
  "**/.factory/droids/",
  "**/.factory/skills/",
  "**/.factory/mcp.json",
  "**/.factory/settings.json",
  // Gemini
  "**/GEMINI.md",
  "**/.gemini/memories/",
  "**/.gemini/commands/",
  "**/.gemini/subagents/",
  "**/.gemini/skills/",
  "**/.geminiignore",
  // Goose
  "**/.goosehints",
  "**/.goose/",
  "**/.gooseignore",
  // GitHub Copilot
  "**/.github/copilot-instructions.md",
  "**/.github/instructions/",
  "**/.github/prompts/",
  "**/.github/agents/",
  "**/.github/skills/",
  "**/.github/hooks/",
  "**/.vscode/mcp.json",
  // Junie
  "**/.junie/guidelines.md",
  "**/.junie/mcp.json",
  // Kilo Code
  "**/.kilocode/rules/",
  "**/.kilocode/skills/",
  "**/.kilocode/workflows/",
  "**/.kilocode/mcp.json",
  "**/.kilocodeignore",
  // Kiro
  "**/.kiro/steering/",
  "**/.kiro/prompts/",
  "**/.kiro/skills/",
  "**/.kiro/agents/",
  "**/.kiro/settings/mcp.json",
  "**/.aiignore",
  // OpenCode
  "**/.opencode/memories/",
  "**/.opencode/command/",
  "**/.opencode/agent/",
  "**/.opencode/skill/",
  "**/.opencode/plugins/",
  // Qwen
  "**/QWEN.md",
  "**/.qwen/memories/",
  // Replit
  "**/replit.md",
  // Roo
  "**/.roo/rules/",
  "**/.roo/skills/",
  "**/.rooignore",
  "**/.roo/mcp.json",
  "**/.roo/subagents/",
  // Warp
  "**/.warp/",
  "**/WARP.md",
  // Others
  ".rulesync/rules/*.local.md",
  "rulesync.local.jsonc",
  "!.rulesync/.aiignore",
];

const isRulesyncHeader = (line: string): boolean => {
  const trimmed = line.trim();
  return trimmed === RULESYNC_HEADER || trimmed === LEGACY_RULESYNC_HEADER;
};

const isRulesyncEntry = (line: string): boolean => {
  const trimmed = line.trim();
  if (trimmed === "" || isRulesyncHeader(line)) {
    return false;
  }
  return RULESYNC_IGNORE_ENTRIES.includes(trimmed);
};

const removeExistingRulesyncEntries = (content: string): string => {
  const lines = content.split("\n");
  const filteredLines: string[] = [];
  let inRulesyncBlock = false;
  let consecutiveEmptyLines = 0;

  for (const line of lines) {
    const trimmed = line.trim();

    if (isRulesyncHeader(line)) {
      inRulesyncBlock = true;
      continue;
    }

    if (inRulesyncBlock) {
      if (trimmed === "") {
        consecutiveEmptyLines++;
        if (consecutiveEmptyLines >= 2) {
          inRulesyncBlock = false;
          consecutiveEmptyLines = 0;
        }
        continue;
      }

      if (isRulesyncEntry(line)) {
        consecutiveEmptyLines = 0;
        continue;
      }

      inRulesyncBlock = false;
      consecutiveEmptyLines = 0;
    }

    if (isRulesyncEntry(line)) {
      continue;
    }

    filteredLines.push(line);
  }

  let result = filteredLines.join("\n");

  while (result.endsWith("\n\n")) {
    result = result.slice(0, -1);
  }

  return result;
};

export const gitignoreCommand = async (): Promise<void> => {
  const gitignorePath = join(process.cwd(), ".gitignore");

  let gitignoreContent = "";

  if (await fileExists(gitignorePath)) {
    gitignoreContent = await readFileContent(gitignorePath);
  }

  const cleanedContent = removeExistingRulesyncEntries(gitignoreContent);

  const rulesyncBlock = [RULESYNC_HEADER, ...RULESYNC_IGNORE_ENTRIES].join("\n");

  const newContent = cleanedContent.trim()
    ? `${cleanedContent.trimEnd()}\n\n${rulesyncBlock}\n`
    : `${rulesyncBlock}\n`;

  if (gitignoreContent === newContent) {
    logger.success(".gitignore is already up to date");
    return;
  }

  await writeFileContent(gitignorePath, newContent);

  logger.success("Updated .gitignore with rulesync entries:");
  for (const entry of RULESYNC_IGNORE_ENTRIES) {
    logger.info(`  ${entry}`);
  }

  logger.info("");
  logger.info(
    "ðŸ’¡ If you're using Google Antigravity, note that rules, workflows, and skills won't load if they're gitignored.",
  );
  logger.info("   You can add the following to .git/info/exclude instead:");
  logger.info("   **/.agent/rules/");
  logger.info("   **/.agent/workflows/");
  logger.info("   **/.agent/skills/");
  logger.info("   For more details: https://github.com/dyoshikawa/rulesync/issues/981");
};
